<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Love Void Network</title>
    <script>// Settings Sync - Apply all stored settings to the current page
document.addEventListener('DOMContentLoaded', function() {
    console.log('Global JS Loaded: Applying settings'); // Debug log

    // Apply favicon/title changes
    const savedIcon = localStorage.getItem('favicon');
    const savedTitle = localStorage.getItem('tabTitle');
    
    // Ensure favicon is updated
    function updateFavicon(iconURL) {
        console.log('Attempting to update favicon:', iconURL); // Debug log

        // Remove existing favicon links
        const existingFavicons = document.querySelectorAll("link[rel='icon'], link[rel='shortcut icon']");
        existingFavicons.forEach(link => {
            console.log('Removing existing favicon:', link); // Debug log
            link.remove();
        });
        
        // Create new favicon link
        const faviconElement = document.createElement('link');
        faviconElement.rel = 'icon';
        faviconElement.href = iconURL;
        document.head.appendChild(faviconElement);
        
        console.log('Favicon updated successfully'); // Debug log
    }
    
    // Apply saved favicon
    if (savedIcon) {
        console.log('Saved icon found:', savedIcon); // Debug log
        try {
            updateFavicon(savedIcon);
        } catch (error) {
            console.error('Error updating favicon:', error);
        }
    } else {
        console.log('No saved icon found'); // Debug log
    }
    
    // Apply saved title
    if (savedTitle) {
        console.log('Saved title found:', savedTitle); // Debug log
        document.title = savedTitle;
    } else {
        console.log('No saved title found'); // Debug log
    }
    
    // Apply search engine preference
    const searchBackend = localStorage.getItem('searchBackend') || 'UV';
    window.currentSearchEngine = searchBackend;
    
    // Check and apply Anti-close protection
    if (localStorage.getItem('anticlose') === 'true') {
        window.addEventListener('beforeunload', function(e) {
            // Only activate if not navigating through our own site
            if (!e.target.location.href.includes("redirect")) {
                e.preventDefault();
                e.returnValue = 'Leave site? Changes you made may not be saved.';
                return e.returnValue;
            }
        });
    }
    
    // Check and apply About:blank cloaking (must run last)
    if (localStorage.getItem('cloaking') === 'true') {
        // Skip if we're already in an about:blank page
        if (window.location.href !== 'about:blank') {
            try {
                const win = window.open('about:blank', '_blank');
                if (win) {
                    // Add the script nodes first
                    const scripts = document.querySelectorAll('script');
                    scripts.forEach(script => {
                        const newScript = win.document.createElement('script');
                        if (script.src) {
                            newScript.src = script.src;
                        } else {
                            newScript.textContent = script.textContent;
                        }
                        win.document.head.appendChild(newScript);
                    });
                    
                    // Copy over stylesheets
                    const styles = document.querySelectorAll('link[rel="stylesheet"]');
                    styles.forEach(style => {
                        const newStyle = win.document.createElement('link');
                        newStyle.rel = 'stylesheet';
                        newStyle.href = style.href;
                        win.document.head.appendChild(newStyle);
                    });
                    
                    // Set title and meta tags
                    win.document.title = document.title;
                    const meta = document.querySelectorAll('meta');
                    meta.forEach(tag => {
                        const newMeta = win.document.createElement('meta');
                        Array.from(tag.attributes).forEach(attr => {
                            newMeta.setAttribute(attr.name, attr.value);
                        });
                        win.document.head.appendChild(newMeta);
                    });
                    
                    // Copy the body
                    win.document.body.innerHTML = document.body.innerHTML;
                    
                    // Close original window
                    setTimeout(() => {
                        window.location.replace('about:blank');
                    }, 100);
                }
            } catch (error) {
                console.error('Error applying about:blank cloaking:', error);
            }
        }
    }
});

// Favicon and Title Change Function
window.changeFavicon = function(iconURL, pageTitle) {
    console.log('Changing favicon:', iconURL, 'Title:', pageTitle); // Debug log

    // Remove existing favicon links
    const existingFavicons = document.querySelectorAll("link[rel='icon'], link[rel='shortcut icon']");
    existingFavicons.forEach(link => link.remove());
    
    // Change favicon
    const faviconElement = document.createElement('link');
    faviconElement.rel = 'icon';
    faviconElement.href = iconURL;
    document.head.appendChild(faviconElement);
    
    // Change title
    if (pageTitle) {
        document.title = pageTitle;
    }
    
    // Save preferences
    localStorage.setItem('favicon', iconURL);
    localStorage.setItem('tabTitle', pageTitle || document.title);
    
    console.log('Favicon and title updated in localStorage'); // Debug log
};

// Additional key terminal shortcut
document.addEventListener("keydown", function(e) {
    if ((e.altKey && e.key == "t")) {
        if (document.getElementById("terminal") != null) {
            document.getElementById("terminal").remove()
            return;
        }
        if (document.getElementById("terminal") == null) {
            renderFile("/terminal.html", "50%", "50%", "terminal")
            return
        }
    }
});

// Render File Function
function renderFile(url, width, height, id) { // Renders URL in a centered iframe w/ w&h set
    let fr = document.createElement("iframe")
    fr.src = url 
    fr.width = width 
    fr.height = height
    fr.id = id
    fr.style.transform = "translate(-50%, -50%)"
    fr.style.position = "absolute"
    fr.style.top = "50%"
    fr.style.left = "50%"
    fr.style.opacity = 0.9
    document.body.appendChild(fr)
}

// Delete Item Function
function deleteItem(id) {
    document.getElementById(id).remove()
}

// Load HTML Function
function loadHTML(url, elementId) {
    fetch(url)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response threw an error  ' + response.statusText);
            }
            return response.text();
        })
        .then(data => {
            document.getElementById(elementId).innerHTML = data;
        })
        .catch(error => console.error('Error loading HTML:', error));
}</script>
    <script src="uv/uv.bundle.js"></script>
    <script src="uv/uv.config.js"></script>
    <script src="/assets/js/favicon-handler.js"></script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-814Y2X3KSF"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-814Y2X3KSF');
    </script>
    <style id="loading-style">
        body,html{margin:0;padding:0;width:100%;height:100%;overflow:hidden}
        #loadingOverlay{position:fixed;top:0;left:0;width:100%;height:100%;background:linear-gradient(135deg,#000 0,#1a1a1a 100%);display:flex;justify-content:center;align-items:center;z-index:999999;}
        #loadingContainer{text-align:center;color:#fff}
        #loadingLogo{
            width: 300px; /* Increased size */
            height: 300px; /* Increased size */
            margin-bottom: 30px;
            display: flex; /* Use flexbox for centering */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }
        #loadingLogo img{
            width: 100%;
            height: auto;
        }
        #loadingText{font-size:1.5em; margin-bottom: 20px;}
        #loadingBar {
            width: 300px;
            height: 20px;
            background-color: #000;
            border-radius: 10px;
            overflow: hidden;
            margin: 0 auto;
        }
        #progressBar {
            width: 0%;
            height: 100%;
            background-color: #007bff;
            transition: width 0.1s linear;
        }
        #contentFrame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            border: none;
        }
        /* ADD YOUR CSS HERE */
    </style>
</head>
<body>
    <div id="loadingOverlay">
        <div id="loadingContainer">
            <div id="loadingLogo">
                <img src="images/LOVEVOIDNEWLOGO.png" alt="Love Void Logo">
            </div>
            <p id="loadingText">Loading...</p>
            <div id="loadingBar">
                <div id="progressBar"></div>
            </div>
        </div>
    </div>
    <iframe id="contentFrame"></iframe>
    <script>
        const progressBar = document.getElementById('progressBar');
        const contentFrame = document.getElementById('contentFrame');
        const loadingOverlay = document.getElementById('loadingOverlay');
        let progress = 0;
        let startTime = performance.now();

        function updateProgress() {
            let now = performance.now();
            let elapsedTime = now - startTime;
            let speed = 100 / 7000;

            let networkSpeedFactor = Math.random() * 0.5 + 0.75;

            progress += speed * elapsedTime * networkSpeedFactor;
            progress = Math.min(progress, 100);

            progressBar.style.width = progress + '%';

            if (progress < 100) {
                startTime = now;
                requestAnimationFrame(updateProgress);
            } else {
                contentFrame.src = '/1/index.html';
                contentFrame.style.display = 'block';
                loadingOverlay.style.display = 'none';
            }
        }

        updateProgress();
    </script>
</body>
</html>
